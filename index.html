<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>To 小糕糕 - 掌心星河</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Zhi+Mang+Xing&display=swap');
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            cursor: pointer; touch-action: none; -webkit-user-select: none;
        }
        
        #status-container {
            position: absolute; top: 20px; left: 0; right: 0;
            text-align: center; pointer-events: none; z-index: 30;
            padding: 0 10px;
        }
        #status-text {
            display: inline-block;
            font-family: 'Zhi Mang Xing', 'KaiTi', cursive;
            font-size: 16px; color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.5); padding: 8px 16px; border-radius: 30px;
            backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.2s;
        }
        .highlight { color: #fff; background: rgba(255, 51, 100, 0.8) !important; box-shadow: 0 0 20px rgba(255,51,100,0.6); transform: scale(1.1); }
        .charging { color: #ffff00; border-color: #ffff00; background: rgba(80, 80, 0, 0.6); } 
        .fist { color: #aaaaff; border-color: #aaaaff; }

        #love-text {
            position: absolute; bottom: 12%; left: 0; right: 0;
            text-align: center; pointer-events: none; z-index: 20;
            font-family: 'Zhi Mang Xing', 'KaiTi', cursive;
            font-size: 28px; color: #ffccdd;
            text-shadow: 0 0 10px #ff3399; 
            opacity: 0; transition: opacity 1s; width: 100%;
        }
        .cursor::after { content: '|'; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        .input_video { display: none; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

</head>
<body>

    <div id="status-container">
        <span id="status-text">正在初始化...</span>
    </div>

    <div id="love-text"><span id="text-content"></span><span class="cursor"></span></div>
    <video class="input_video"></video>
    
    <script>
        // ================= 配置区域 =================
        // 确保 photo.jpg 已上传到 GitHub 仓库根目录。
        const yourPhotoUrl = "photo.jpg"; 
        // ===========================================

        const statusText = document.getElementById('status-text');
        const loveTextContainer = document.getElementById('love-text');
        const textContent = document.getElementById('text-content');
        const startTime = Date.now(); 
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        window.onerror = function(msg) {
            return false;
        };

        if (typeof THREE === 'undefined') {
            statusText.innerHTML = "❌ 资源加载超时，请刷新";
        } else {
            init();
        }

        function init() {
            statusText.innerHTML = "正在启动星际引擎...";

            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050208, 0.002); 
            scene.background = new THREE.Color(0x050208);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = (window.innerWidth < window.innerHeight) ? 180 : 120;

            const renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            document.body.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.6; bloomPass.strength = 0.7; bloomPass.radius = 0.5;    
            const composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            const textureLoader = new THREE.TextureLoader();
            
            function createCircleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
                return new THREE.CanvasTexture(canvas);
            }
            const circleTexture = createCircleTexture();

            function createPlaceholderPhoto() {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ff99cc';
                ctx.beginPath(); ctx.arc(128, 128, 120, 0, Math.PI*2); ctx.fill();
                ctx.font = '30px Arial'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
                ctx.fillText("NO PHOTO", 128, 138);
                return new THREE.CanvasTexture(canvas);
            }

            // --- 照片系统 ---
            let photoMesh = null;
            const photoGeo = new THREE.CircleGeometry(25, 64); 
            const photoMat = new THREE.MeshBasicMaterial({
                map: createPlaceholderPhoto(),
                side: THREE.DoubleSide, transparent: true, opacity: 0, 
                depthWrite: false, blending: THREE.AdditiveBlending
            });
            photoMesh = new THREE.Mesh(photoGeo, photoMat);
            photoMesh.position.z = 5; 
            photoMesh.visible = false; 
            scene.add(photoMesh); 

            // 优化：添加错误处理 (.catch) 解决 photo.jpg 404 警告
            if (yourPhotoUrl) {
                textureLoader.load(yourPhotoUrl, (tex) => {
                    photoMesh.material.map = tex;
                    photoMesh.material.needsUpdate = true;
                }, undefined, (err) => {
                    console.warn(`照片加载失败 (404/网络错误): ${yourPhotoUrl}`, err);
                    photoMesh.visible = false; // 加载失败则隐藏照片
                });
            } else {
                photoMesh.visible = false;
            }


            // --- 星空 ---
            function createStarField(count, size, range, color, opacity) {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                for(let i=0; i<count; i++) {
                    pos[i*3] = (Math.random() - 0.5) * range;
                    pos[i*3+1] = (Math.random() - 0.5) * range;
                    pos[i*3+2] = (Math.random() - 0.5) * range;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({
                    map: circleTexture, color: color, size: size, transparent: true, 
                    opacity: opacity, blending: THREE.AdditiveBlending, sizeAttenuation: true, depthWrite: false
                });
                return new THREE.Points(geo, mat);
            }
            scene.add(createStarField(isMobile ? 1500 : 3000, 1.0, 1500, 0x88ccff, 0.2)); 
            scene.add(createStarField(isMobile ? 400 : 800, 2.5, 800, 0xffccff, 0.5));

            // --- 心形粒子 ---
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = isMobile ? 15000 : 20000; 
            const targetPositions = new Float32Array(particlesCount * 3);
            const currentPositions = new Float32Array(particlesCount * 3);
            const velocities = new Float32Array(particlesCount * 3);
            const colors = new Float32Array(particlesCount * 3); 
            
            const colorBottom = new THREE.Color(0x8B0000); 
            const colorMiddle = new THREE.Color(0xff1493); 
            const colorTop = new THREE.Color(0xffffff); 

            let pIndex = 0;
            while (pIndex < particlesCount) {
                const x = Math.random() * 6 - 3; const y = Math.random() * 6 - 3; const z = Math.random() * 6 - 3;
                const a = x * x + (9/4) * y * y + z * z - 1;
                const check = a * a * a - x * x * z * z * z - (9/80) * y * y * z * z * z;

                if (check < 0) {
                    const scale = 35; 
                    const tx = x * scale + (Math.random()-0.5)*0.6;
                    const ty = y * scale + (Math.random()-0.5)*0.6;
                    const tz = z * scale + (Math.random()-0.5)*0.6;
                    
                    targetPositions[pIndex*3] = tx; targetPositions[pIndex*3+1] = ty; targetPositions[pIndex*3+2] = tz;
                    currentPositions[pIndex*3] = tx; currentPositions[pIndex*3+1] = ty; currentPositions[pIndex*3+2] = tz;
                    
                    let normalizedY = (ty + 80) / 160; 
                    normalizedY = Math.max(0, Math.min(1, normalizedY));
                    const finalColor = new THREE.Color();
                    if (normalizedY < 0.5) finalColor.lerpColors(colorBottom, colorMiddle, normalizedY * 2);
                    else finalColor.lerpColors(colorMiddle, colorTop, (normalizedY - 0.5) * 2);

                    colors[pIndex*3] = finalColor.r; colors[pIndex*3+1] = finalColor.g; colors[pIndex*3+2] = finalColor.b;
                    pIndex++;
                }
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); 
            
            const heartMaterial = new THREE.PointsMaterial({
                map: circleTexture, size: isMobile ? 1.5 : 1.1, vertexColors: true, 
                transparent: true, opacity: 0.95,
                blending: THREE.AdditiveBlending, depthWrite: false,
            });

            const heartGroup = new THREE.Group();
            const particlesMesh = new THREE.Points(particlesGeometry, heartMaterial);
            heartGroup.add(particlesMesh);
            scene.add(heartGroup);

            // --- 名字 Sprite ---
            let nameSprite = null;
            function createNameSprite() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 1024; canvas.height = 512;
                ctx.shadowColor = "#ff33aa"; ctx.shadowBlur = 35; ctx.fillStyle = "#ffffff";
                ctx.font = "bold 140px 'Zhi Mang Xing', 'KaiTi', sans-serif";
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText("小糕糕", 512, 256);
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 1.0, depthTest: false });
                const sprite = new THREE.Sprite(mat);
                sprite.position.y = -2; sprite.position.z = 15; 
                return sprite;
            }
            
            document.fonts.ready.then(() => {
                nameSprite = createNameSprite();
                scene.add(nameSprite); 
                statusText.innerHTML = "✨ 星河已连接 | 捏合手指触发魔法 ✨";
                setTimeout(startTypewriter, 2000);
            });

            const loveMessages = ["致 亲爱的小糕糕", "宇宙很大...", "星辰即使碎裂...", "也会化作光去找你。", "在这片专属星空里", "你永远是中心。", "❤️ 永远爱你 ❤️"];
            let msgIndex = 0; let charIndex = 0; let isDeleting = false;
            function startTypewriter() { loveTextContainer.style.opacity = 1; typeWriter(); }
            function typeWriter() {
                const currentMsg = loveMessages[msgIndex];
                if (isDeleting) { textContent.innerHTML = currentMsg.substring(0, charIndex - 1); charIndex--; }
                else { textContent.innerHTML = currentMsg.substring(0, charIndex + 1); charIndex++; }
                let typeSpeed = 200;
                if (!isDeleting && charIndex === currentMsg.length) { typeSpeed = 2500; isDeleting = true; if (msgIndex === loveMessages.length - 1) { isDeleting = false; return; }}
                else if (isDeleting && charIndex === 0) { isDeleting = false; msgIndex++; typeSpeed = 500; }
                setTimeout(typeWriter, typeSpeed);
            }

            // --- 爆炸逻辑 ---
            let isExploding = false; let explosionTime = 0;
            let pinchTimer = 0; 
            
            function triggerExplosion() {
                if (isExploding) return;
                if (Date.now() - startTime < 3000) return;

                isExploding = true; explosionTime = 0;
                if(nameSprite) nameSprite.visible = false;
                
                if(photoMesh && yourPhotoUrl) {
                    photoMesh.visible = true;
                    photoMesh.material.opacity = 0;
                }

                statusText.innerHTML = "✨ 怦然心动 ✨"; statusText.classList.add("highlight");
                if (navigator.vibrate) navigator.vibrate(200);

                const colorsArr = particlesGeometry.attributes.color.array;
                for(let i=0; i<particlesCount; i++) {
                    const x = targetPositions[i*3]; const y = targetPositions[i*3+1]; const z = targetPositions[i*3+2];
                    const len = Math.sqrt(x*x + y*y + z*z);
                    const force = 4.0 + Math.random() * 6.0;
                    velocities[i*3] = (x/len) * force; velocities[i*3+1] = (y/len) * force; velocities[i*3+2] = (z/len) * force;
                    colorsArr[i*3] = 1.0; colorsArr[i*3+1] = 0.9; colorsArr[i*3+2] = 0.7 + Math.random()*0.3; 
                }
                particlesGeometry.attributes.color.needsUpdate = true;
            }
            document.body.addEventListener('click', triggerExplosion);
            document.body.addEventListener('touchstart', (e)=>{ e.preventDefault(); triggerExplosion(); }, {passive: false});

            // --- 动画循环 ---
            let mode = 'waiting'; let time = 0;
            let targetRotX = 0, targetRotY = 0, targetScale = 1.0;
            let curRotX = 0, curRotY = 0, curScale = 1.0;
            const initialRotationX = -Math.PI / 12;

            function animate() {
                requestAnimationFrame(animate);
                time += 0.02;

                const positions = particlesGeometry.attributes.position.array;
                const colorsArr = particlesGeometry.attributes.color.array;

                if (isExploding) {
                    explosionTime += 0.02;
                    if(photoMesh && photoMesh.material.opacity < 1.0) photoMesh.material.opacity += 0.04;

                    for(let i=0; i<particlesCount; i++) {
                        positions[i*3] += velocities[i*3]; positions[i*3+1] += velocities[i*3+1]; positions[i*3+2] += velocities[i*3+2];
                        velocities[i*3] *= 0.92; velocities[i*3+1] *= 0.92; velocities[i*3+2] *= 0.92;
                    }
                    if (explosionTime > 1.8) {
                        let allBack = true;
                        for(let i=0; i<particlesCount; i++) {
                            positions[i*3] += (targetPositions[i*3] - positions[i*3]) * 0.08;
                            positions[i*3+1] += (targetPositions[i*3+1] - positions[i*3+1]) * 0.08;
                            positions[i*3+2] += (targetPositions[i*3+2] - positions[i*3+2]) * 0.08;
                            colorsArr[i*3] += (1.0 - colorsArr[i*3]) * 0.05;
                            colorsArr[i*3+1] += (0.2 - colorsArr[i*3+1]) * 0.05;
                            colorsArr[i*3+2] += (0.6 - colorsArr[i*3+2]) * 0.05;
                            if (Math.abs(positions[i*3] - targetPositions[i*3]) > 1.0) allBack = false;
                        }
                        particlesGeometry.attributes.color.needsUpdate = true;
                        
                        if (allBack && explosionTime > 3.5) {
                            isExploding = false;
                            if(nameSprite) nameSprite.visible = true;
                            statusText.innerHTML = "✨ 星河已连接 | 捏合手指触发魔法 ✨";
                            statusText.classList.remove("highlight");
                        }
                    }
                } else {
                    // 强制照片消失逻辑 (仅当 photoUrl 存在时)
                    if(photoMesh && yourPhotoUrl) {
                        if (photoMesh.material.opacity > 0.02) {
                            photoMesh.material.opacity -= 0.03; 
                        } else {
                            photoMesh.material.opacity = 0;
                            photoMesh.visible = false; 
                        }
                    }
                }
                particlesGeometry.attributes.position.needsUpdate = true;

                // 交互灵敏度提升
                curRotX += (targetRotX - curRotX) * 0.2; 
                curRotY += (targetRotY - curRotY) * 0.2;
                curScale += (targetScale - curScale) * 0.2;

                heartGroup.rotation.y = curRotY; 
                heartGroup.rotation.x = initialRotationX + curRotX; 

                const currentBeat = isExploding ? 1.0 : (Math.pow(Math.sin(time * 4), 2) * 0.1 + 0.96);
                const finalScale = curScale * currentBeat;
                heartGroup.scale.set(finalScale, finalScale, finalScale);
                
                if (photoMesh && yourPhotoUrl) {
                    photoMesh.position.x = heartGroup.position.x;
                    photoMesh.position.y = heartGroup.position.y + Math.sin(time * 2) * 1; 
                    photoMesh.scale.set(finalScale, finalScale, 1); 
                }
                if (nameSprite) {
                    nameSprite.position.x = heartGroup.position.x;
                    nameSprite.position.y = heartGroup.position.y - 2 + Math.sin(time * 2) * 1;
                    nameSprite.scale.set(50 * finalScale, 25 * finalScale, 1);
                }

                composer.render();
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                camera.position.z = (window.innerWidth < window.innerHeight) ? 180 : 120;
            });


            // --- MediaPipe / Camera 启动 (修正分辨率和错误捕获) ---
            try {
                const videoElement = document.getElementsByClassName('input_video')[0];
                const Hands = window.Hands;
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                
                hands.setOptions({ 
                    maxNumHands: 1, 
                    modelComplexity: isMobile ? 0 : 1, // 移动端用Lite模型(0)
                    minDetectionConfidence: 0.4, 
                    minTrackingConfidence: 0.4 
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        const wrist = landmarks[0]; 
                        const thumbTip = landmarks[4]; const middleTip = landmarks[12];
                        
                        // 1. 张开/握拳检测
                        const tips = [8, 12, 16, 20]; const bases = [5, 9, 13, 17];
                        let tD = 0; let bD = 0;
                        for(let i=0; i<4; i++){
                            tD += Math.sqrt(Math.pow(landmarks[tips[i]].x - wrist.x, 2) + Math.pow(landmarks[tips[i]].y - wrist.y, 2));
                            bD += Math.sqrt(Math.pow(landmarks[bases[i]].x - wrist.x, 2) + Math.pow(landmarks[bases[i]].y - wrist.y, 2));
                        }
                        const ratio = tD / bD; 
                        
                        // 2. 自适应捏合判定
                        const handSize = Math.sqrt(Math.pow(landmarks[5].x - wrist.x, 2) + Math.pow(landmarks[5].y - wrist.y, 2));
                        const snapDist = Math.sqrt(Math.pow(thumbTip.x - middleTip.x, 2) + Math.pow(thumbTip.y - middleTip.y, 2));
                        
                        const isPinching = snapDist < (handSize * 0.3);
                        
                        if (isPinching && !isExploding) {
                            pinchTimer++;
                            statusText.innerHTML = "⚡ 蓄力中... ⚡";
                            statusText.classList.add("charging");
                            targetScale *= 1.1; 
                            if (navigator.vibrate && pinchTimer % 5 === 0) navigator.vibrate(10);

                            if (pinchTimer > 8) {
                                triggerExplosion();
                                pinchTimer = 0;
                            }
                        } else {
                            pinchTimer = 0;
                            statusText.classList.remove("charging");

                            if (ratio < 1.3) {
                                targetScale = 0.5;
                                if (!isExploding) statusText.innerHTML = "✊ 握拳缩小";
                            } else {
                                let s = (ratio - 1.1) / 0.6; 
                                targetScale = 0.5 + (Math.max(0, Math.min(1, s)) * 1.8); 
                                if (!isExploding) statusText.innerHTML = "✨ 星河已连接 | 捏合触发魔法 ✨";
                            }
                        }

                        if (mode !== 'hand') { mode = 'hand'; }
                        const middleBase = landmarks[9]; 
                        targetRotY = (middleBase.x - 0.5) * 4.0;
                        let tilt = (middleBase.z - wrist.z) * 12; 
                        targetRotX = Math.max(-0.5, Math.min(0.5, tilt));
                    } else { 
                        if (mode === 'hand') { targetScale = 1.0; targetRotX = 0; targetRotY = 0; pinchTimer = 0; } 
                    }
                });
                
                // 关键修正：将移动端分辨率改为 320x240，确保宽度和高度都是 4 的倍数，避免 WASM 崩溃
                const cameraUtils = new Camera(videoElement, { 
                    onFrame: async () => { await hands.send({image: videoElement}); }, 
                    width: isMobile ? 320 : 640, 
                    height: isMobile ? 240 : 480 
                });
                
                cameraUtils.start().catch((error) => {
                    console.error("Camera Start Error:", error);
                    let errorMsg = "❌ 摄像头启动失败 [未知错误]";
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        errorMsg = "❌ 摄像头权限被拒绝，请检查浏览器设置！";
                    } else if (error.name === 'SecurityError') {
                        errorMsg = "❌ 必须在 HTTPS 或本地服务器 (localhost) 上运行！";
                    }
                    
                    statusText.innerHTML = errorMsg;
                    statusText.style.color = "#ff5555";
                    statusText.classList.remove("highlight");
                    
                    mode = 'mouse';
                    setTimeout(() => { 
                        statusText.innerHTML = "未检测到手势，请点击屏幕触发烟花"; 
                    }, 500); 
                });
                
            } catch(e) { 
                console.error("AI Initialization Error:", e); 
                statusText.innerHTML = "❌ AI 初始化失败，请检查网络连接或资源路径";
                statusText.style.color = "#ff5555";
            }
        }
    </script>
</body>
</html>