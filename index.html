<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>To å°ç³•ç³• - æŒå¿ƒæ˜Ÿæ²³</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Zhi+Mang+Xing&display=swap');
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            cursor: pointer; touch-action: none; -webkit-user-select: none;
        }
        
        #status-container {
            position: absolute; top: 20px; left: 0; right: 0;
            text-align: center; pointer-events: none; z-index: 30;
            padding: 0 10px;
        }
        #status-text {
            display: inline-block;
            font-family: 'Zhi Mang Xing', 'KaiTi', cursive;
            font-size: 16px; color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.5); padding: 8px 16px; border-radius: 30px;
            backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.2s;
        }
        .highlight { color: #fff; background: rgba(255, 51, 100, 0.8) !important; box-shadow: 0 0 20px rgba(255,51,100,0.6); transform: scale(1.1); }
        .charging { color: #ffff00; border-color: #ffff00; background: rgba(80, 80, 0, 0.6); } 
        .fist { color: #aaaaff; border-color: #aaaaff; }

        #love-text {
            position: absolute; bottom: 12%; left: 0; right: 0;
            text-align: center; pointer-events: none; z-index: 20;
            font-family: 'Zhi Mang Xing', 'KaiTi', cursive;
            font-size: 28px; color: #ffccdd;
            text-shadow: 0 0 10px #ff3399; 
            opacity: 0; transition: opacity 1s; width: 100%;
        }
        .cursor::after { content: '|'; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        .input_video { display: none; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

</head>
<body>

    <div id="status-container">
        <span id="status-text">æ­£åœ¨åˆå§‹åŒ–...</span>
    </div>

    <div id="love-text"><span id="text-content"></span><span class="cursor"></span></div>
    <video class="input_video"></video>
    
    <script>
        // ================= é…ç½®åŒºåŸŸ =================
        const yourPhotoUrl = "photo.jpg"; 
        // ===========================================

        const statusText = document.getElementById('status-text');
        const loveTextContainer = document.getElementById('love-text');
        const textContent = document.getElementById('text-content');
        const startTime = Date.now(); 
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        window.onerror = function(msg) {
            return false;
        };

        if (typeof THREE === 'undefined') {
            statusText.innerHTML = "âŒ èµ„æºåŠ è½½è¶…æ—¶ï¼Œè¯·åˆ·æ–°";
        } else {
            init();
        }

        let lastTouchX = null;
        let lastTouchY = null;
        let touchTimer = 0; 

        function init() {
            const initialMode = isMobile ? 'touch' : 'waiting'; 
            statusText.innerHTML = "æ­£åœ¨å¯åŠ¨æ˜Ÿé™…å¼•æ“...";

            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050208, 0.002); 
            scene.background = new THREE.Color(0x050208);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = (window.innerWidth < window.innerHeight) ? 180 : 120;

            const renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            document.body.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.6; bloomPass.strength = 0.7; bloomPass.radius = 0.5;    
            const composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            const textureLoader = new THREE.TextureLoader();
            
            function createCircleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
                return new THREE.CanvasTexture(canvas);
            }
            const circleTexture = createCircleTexture();

            function createPlaceholderPhoto() {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ff99cc';
                ctx.beginPath(); ctx.arc(128, 128, 120, 0, Math.PI*2); ctx.fill();
                ctx.font = '30px Arial'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
                ctx.fillText("NO PHOTO", 128, 138);
                return new THREE.CanvasTexture(canvas);
            }

            // --- ç…§ç‰‡ç³»ç»Ÿ ---
            let photoMesh = null;
            // ğŸŒŸ ä¿®æ­£ 1.A: å¢å¤§ç…§ç‰‡åŸºå‡†å°ºå¯¸ï¼Œä½¿å…¶åœ¨çˆ†ç‚¸æ—¶å æ®å±å¹•ä¸€åŠ
            const photoGeo = new THREE.CircleGeometry(50, 64); 
            const photoMat = new THREE.MeshBasicMaterial({
                map: createPlaceholderPhoto(),
                side: THREE.DoubleSide, transparent: true, opacity: 0, 
                depthWrite: true 
            });
            photoMesh = new THREE.Mesh(photoGeo, photoMat);
            photoMesh.position.z = 5; 
            photoMesh.visible = false; 
            scene.add(photoMesh); 

            if (yourPhotoUrl) {
                textureLoader.load(yourPhotoUrl, (tex) => {
                    photoMesh.material.map = tex;
                    photoMesh.material.needsUpdate = true;
                }, undefined, (err) => {
                    console.warn(`ç…§ç‰‡åŠ è½½å¤±è´¥ (404/ç½‘ç»œé”™è¯¯): ${yourPhotoUrl}`, err);
                    photoMesh.visible = false; 
                });
            } else {
                photoMesh.visible = false;
            }


            // --- æ˜Ÿç©ºå’Œç²’å­åˆ›å»º (ä¿æŒä¸å˜) ---
            function createStarField(count, size, range, color, opacity) {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                for(let i=0; i<count; i++) {
                    pos[i*3] = (Math.random() - 0.5) * range;
                    pos[i*3+1] = (Math.random() - 0.5) * range;
                    pos[i*3+2] = (Math.random() - 0.5) * range;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({
                    map: circleTexture, color: color, size: size, transparent: true, 
                    opacity: opacity, blending: THREE.AdditiveBlending, sizeAttenuation: true, depthWrite: false
                });
                return new THREE.Points(geo, mat);
            }
            scene.add(createStarField(isMobile ? 1500 : 3000, 1.0, 1500, 0x88ccff, 0.2)); 
            scene.add(createStarField(isMobile ? 400 : 800, 2.5, 800, 0xffccff, 0.5));

            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = isMobile ? 15000 : 20000; 
            const targetPositions = new Float32Array(particlesCount * 3);
            const currentPositions = new Float32Array(particlesCount * 3);
            const velocities = new Float32Array(particlesCount * 3);
            const colors = new Float32Array(particlesCount * 3); 
            
            const colorBottom = new THREE.Color(0x8B0000); 
            const colorMiddle = new THREE.Color(0xff1493); 
            const colorTop = new THREE.Color(0xffffff); 

            let pIndex = 0;
            while (pIndex < particlesCount) {
                const x = Math.random() * 6 - 3; const y = Math.random() * 6 - 3; const z = Math.random() * 6 - 3;
                const a = x * x + (9/4) * y * y + z * z - 1;
                const check = a * a * a - x * x * z * z * z - (9/80) * y * y * z * z * z;

                if (check < 0) {
                    const scale = 35; 
                    const tx = x * scale + (Math.random()-0.5)*0.6;
                    const ty = y * scale + (Math.random()-0.5)*0.6;
                    const tz = z * scale + (Math.random()-0.5)*0.6;
                    
                    targetPositions[pIndex*3] = tx; targetPositions[pIndex*3+1] = ty; targetPositions[pIndex*3+2] = tz;
                    currentPositions[pIndex*3] = tx; currentPositions[pIndex*3+1] = ty; currentPositions[pIndex*3+2] = tz;
                    
                    let normalizedY = (ty + 80) / 160; 
                    normalizedY = Math.max(0, Math.min(1, normalizedY));
                    const finalColor = new THREE.Color();
                    if (normalizedY < 0.5) finalColor.lerpColors(colorBottom, colorMiddle, normalizedY * 2);
                    else finalColor.lerpColors(colorMiddle, colorTop, (normalizedY - 0.5) * 2);

                    colors[pIndex*3] = finalColor.r; colors[pIndex*3+1] = finalColor.g; colors[pIndex*3+2] = finalColor.b;
                    pIndex++;
                }
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); 
            
            const heartMaterial = new THREE.PointsMaterial({
                map: circleTexture, size: isMobile ? 1.5 : 1.1, vertexColors: true, 
                transparent: true, opacity: 0.95,
                blending: THREE.AdditiveBlending, depthWrite: false,
            });

            const heartGroup = new THREE.Group();
            const particlesMesh = new THREE.Points(particlesGeometry, heartMaterial);
            heartGroup.add(particlesMesh);
            scene.add(heartGroup);

            // --- åå­— Sprite (ä¿æŒä¸å˜) ---
            let nameSprite = null;
            function createNameSprite() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 1024; canvas.height = 512;
                ctx.shadowColor = "#ff33aa"; ctx.shadowBlur = 35; ctx.fillStyle = "#ffffff";
                ctx.font = "bold 140px 'Zhi Mang Xing', 'KaiTi', sans-serif";
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText("å°ç³•ç³•", 512, 256);
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 1.0, depthTest: false });
                const sprite = new THREE.Sprite(mat);
                sprite.position.y = -2; sprite.position.z = 15; 
                return sprite;
            }
            
            document.fonts.ready.then(() => {
                nameSprite = createNameSprite();
                scene.add(nameSprite); 
                
                if (isMobile) {
                    statusText.innerHTML = "âœ¨ è§¦å±æ¨¡å¼ | å•æŒ‡æ‹–åŠ¨ | åŒæŒ‡æåˆè§¦å‘é­”æ³• âœ¨";
                } else {
                    statusText.innerHTML = "âœ¨ æ‘„åƒå¤´å¯åŠ¨ä¸­ | æ¡æ‹³ç¼©å° | æåˆè§¦å‘é­”æ³• âœ¨";
                }
                
                setTimeout(startTypewriter, 2000);
            });

            // --- æ–‡å­—æ‰“å­—æœºæ•ˆæœ (ä¿æŒä¸å˜) ---
            const loveMessages = ["è‡´ äº²çˆ±çš„å°ç³•ç³•", "å®‡å®™å¾ˆå¤§...", "æ˜Ÿè¾°å³ä½¿ç¢è£‚...", "ä¹Ÿä¼šåŒ–ä½œå…‰å»æ‰¾ä½ ã€‚", "åœ¨è¿™ç‰‡ä¸“å±æ˜Ÿç©ºé‡Œ", "ä½ æ°¸è¿œæ˜¯ä¸­å¿ƒã€‚", "â¤ï¸ æ°¸è¿œçˆ±ä½  â¤ï¸"];
            let msgIndex = 0; let charIndex = 0; let isDeleting = false;
            function startTypewriter() { loveTextContainer.style.opacity = 1; typeWriter(); }
            function typeWriter() {
                const currentMsg = loveMessages[msgIndex];
                if (isDeleting) { textContent.innerHTML = currentMsg.substring(0, charIndex - 1); charIndex--; }
                else { textContent.innerHTML = currentMsg.substring(0, charIndex + 1); charIndex++; }
                let typeSpeed = 200;
                if (!isDeleting && charIndex === currentMsg.length) { typeSpeed = 2500; isDeleting = true; if (msgIndex === loveMessages.length - 1) { isDeleting = false; return; }}
                else if (isDeleting && charIndex === 0) { isDeleting = false; msgIndex++; typeSpeed = 500; }
                setTimeout(typeWriter, typeSpeed);
            }

            // --- çˆ†ç‚¸é€»è¾‘ (ä¿æŒä¸å˜) ---
            let isExploding = false; let explosionTime = 0;
            let pinchTimer = 0; 
            
            function triggerExplosion() {
                if (isExploding) return;
                if (Date.now() - startTime < 3000) return;

                isExploding = true; explosionTime = 0;
                if(nameSprite) nameSprite.visible = false;
                
                if(photoMesh && yourPhotoUrl) {
                    photoMesh.visible = true;
                    photoMesh.material.opacity = 0;
                }

                statusText.innerHTML = "âœ¨ æ€¦ç„¶å¿ƒåŠ¨ âœ¨"; statusText.classList.add("highlight");
                if (navigator.vibrate) navigator.vibrate(200);

                const colorsArr = particlesGeometry.attributes.color.array;
                for(let i=0; i<particlesCount; i++) {
                    const x = targetPositions[i*3]; const y = targetPositions[i*3+1]; const z = targetPositions[i*3+2];
                    const len = Math.sqrt(x*x + y*y + z*z);
                    const force = 4.0 + Math.random() * 6.0;
                    velocities[i*3] = (x/len) * force; velocities[i*3+1] = (y/len) * force; velocities[i*3+2] = (z/len) * force;
                    colorsArr[i*3] = 1.0; colorsArr[i*3+1] = 0.9; colorsArr[i*3+2] = 0.7 + Math.random()*0.3; 
                }
                particlesGeometry.attributes.color.needsUpdate = true;
            }
            
            document.body.addEventListener('click', () => { if (!isMobile) triggerExplosion(); });
            
            // --- è§¦å±äº‹ä»¶å¤„ç† ---
            let initialDistance = 0;
            let lastScale = 1.0;
            let lastPointerX = 0;
            let lastPointerY = 0;
            
            if (isMobile) {
                document.body.addEventListener('touchstart', (e) => {
                    e.preventDefault(); 
                    if (isExploding) return;

                    if (e.touches.length === 2) {
                        initialDistance = getDistance(e.touches[0], e.touches[1]);
                        lastScale = targetScale;
                        pinchTimer = 0; 
                    } else if (e.touches.length === 1) {
                        lastPointerX = e.touches[0].pageX;
                        lastPointerY = e.touches[0].pageY;
                        pinchTimer = 0;
                    }
                }, {passive: false});

                document.body.addEventListener('touchmove', (e) => {
                    e.preventDefault(); 
                    if (isExploding) return;

                    if (e.touches.length === 2) {
                        const currentDistance = getDistance(e.touches[0], e.touches[1]);
                        
                        let scaleFactor = currentDistance / initialDistance;
                        targetScale = Math.max(0.5, Math.min(2.5, lastScale * scaleFactor)); 
                        
                        if (currentDistance / initialDistance < 0.6) {
                            pinchTimer++;
                            statusText.innerHTML = "âš¡ è“„åŠ›ä¸­... âš¡";
                            statusText.classList.add("charging");
                            if (pinchTimer > 5) {
                                triggerExplosion();
                                pinchTimer = 0;
                            }
                        }
                    } else if (e.touches.length === 1) {
                        const dx = e.touches[0].pageX - lastPointerX;
                        const dy = e.touches[0].pageY - lastPointerY;
                        
                        // ğŸŒŸ ä¿®æ­£ 2: å·¦å³æ—‹è½¬ï¼ˆYè½´ï¼‰ä¿æŒå‡æ³•ï¼›ä¸Šä¸‹æ—‹è½¬ï¼ˆXè½´ï¼‰æ”¹ä¸ºå‡æ³•ï¼Œå¯èƒ½æ›´ç¬¦åˆä½ è®¾å¤‡çš„ä½“éªŒ
                        targetRotY -= dx * 0.005; 
                        targetRotX -= dy * 0.005; 
                        targetRotX = Math.max(-1.0, Math.min(1.0, targetRotX)); 
                        
                        lastPointerX = e.touches[0].pageX;
                        lastPointerY = e.touches[0].pageY;
                    }
                }, {passive: false});

                document.body.addEventListener('touchend', () => {
                    pinchTimer = 0;
                    statusText.classList.remove("charging");
                    statusText.innerHTML = "âœ¨ è§¦å±æ¨¡å¼ | å•æŒ‡æ‹–åŠ¨ | åŒæŒ‡æåˆè§¦å‘é­”æ³• âœ¨";
                });
            }

            function getDistance(touch1, touch2) {
                return Math.sqrt(Math.pow(touch1.pageX - touch2.pageX, 2) + Math.pow(touch1.pageY - touch2.pageY, 2));
            }


            // --- åŠ¨ç”»å¾ªç¯ ---
            let mode = initialMode; 
            let time = 0;
            let targetRotX = 0, targetRotY = 0, targetScale = 1.0;
            let curRotX = 0, curRotY = 0, curScale = 1.0;
            const initialRotationX = -Math.PI / 12;

            function animate() {
                requestAnimationFrame(animate);
                time += 0.02;

                const positions = particlesGeometry.attributes.position.array;
                const colorsArr = particlesGeometry.attributes.color.array;

                if (isExploding) {
                    explosionTime += 0.02;
                    if(photoMesh && photoMesh.material.opacity < 1.0) photoMesh.material.opacity += 0.04;

                    for(let i=0; i<particlesCount; i++) {
                        positions[i*3] += velocities[i*3]; positions[i*3+1] += velocities[i*3+1]; positions[i*3+2] += velocities[i*3+2];
                        velocities[i*3] *= 0.92; velocities[i*3+1] *= 0.92; velocities[i*3+2] *= 0.92;
                    }
                    if (explosionTime > 1.8) {
                        let allBack = true;
                        for(let i=0; i<particlesCount; i++) {
                            positions[i*3] += (targetPositions[i*3] - positions[i*3]) * 0.08;
                            positions[i*3+1] += (targetPositions[i*3+1] - positions[i*3+1]) * 0.08;
                            positions[i*3+2] += (targetPositions[i*3+2] - positions[i*3+2]) * 0.08;
                            colorsArr[i*3] += (1.0 - colorsArr[i*3]) * 0.05;
                            colorsArr[i*3+1] += (0.2 - colorsArr[i*3+1]) * 0.05;
                            colorsArr[i*3+2] += (0.6 - colorsArr[i*3+2]) * 0.05;
                            if (Math.abs(positions[i*3] - targetPositions[i*3]) > 1.0) allBack = false;
                        }
                        particlesGeometry.attributes.color.needsUpdate = true;
                        
                        if (allBack && explosionTime > 3.5) {
                            isExploding = false;
                            if(nameSprite) nameSprite.visible = true;
                            statusText.innerHTML = isMobile ? "âœ¨ è§¦å±æ¨¡å¼ | åŒæŒ‡æåˆè§¦å‘é­”æ³• âœ¨" : "âœ¨ æ˜Ÿæ²³å·²è¿æ¥ | æåˆæ‰‹æŒ‡è§¦å‘é­”æ³• âœ¨";
                            statusText.classList.remove("highlight");
                        }
                    }
                } else {
                    if(photoMesh && yourPhotoUrl) {
                        if (photoMesh.material.opacity > 0.02) {
                            photoMesh.material.opacity -= 0.03; 
                        } else {
                            photoMesh.material.opacity = 0;
                            photoMesh.visible = false; 
                        }
                    }
                }
                particlesGeometry.attributes.position.needsUpdate = true;

                // --- äº¤äº’æ›´æ–°é€»è¾‘ ---
                curRotX += (targetRotX - curRotX) * 0.2; 
                curRotY += (targetRotY - curRotY) * 0.2;
                curScale += (targetScale - curScale) * 0.2;

                heartGroup.rotation.y = curRotY; 
                heartGroup.rotation.x = initialRotationX + curRotX; 

                const currentBeat = isExploding ? 1.0 : (Math.pow(Math.sin(time * 4), 2) * 0.1 + 0.96);
                const finalScale = curScale * currentBeat;
                heartGroup.scale.set(finalScale, finalScale, finalScale);
                
                if (photoMesh && yourPhotoUrl) {
                    // ğŸŒŸ ä¿®æ­£ 1.B: ç§»é™¤é¢å¤–çš„ç¼©æ”¾å› å­ï¼Œè®©å®ƒåªè·Ÿéš finalScaleï¼Œä½†ç”±äºåŸºå‡†å°ºå¯¸å¤§ï¼Œç°åœ¨çœ‹èµ·æ¥å°±ä¼šå¾ˆå¤§
                    const photoScaleFactor = finalScale; 
                    
                    photoMesh.position.x = heartGroup.position.x;
                    photoMesh.position.y = heartGroup.position.y + Math.sin(time * 2) * 1; 
                    photoMesh.scale.set(photoScaleFactor, photoScaleFactor, 1); 
                }
                if (nameSprite) {
                    nameSprite.position.x = heartGroup.position.x;
                    nameSprite.position.y = heartGroup.position.y - 2 + Math.sin(time * 2) * 1;
                    nameSprite.scale.set(50 * finalScale, 25 * finalScale, 1);
                }

                composer.render();
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                camera.position.z = (window.innerWidth < window.innerHeight) ? 180 : 120;
            });


            // --- MediaPipe / Camera å¯åŠ¨ (ä»…åœ¨ PC ç«¯æ‰§è¡Œ) ---
            if (!isMobile) {
                try {
                    const videoElement = document.getElementsByClassName('input_video')[0];
                    const Hands = window.Hands;
                    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                    
                    hands.setOptions({ 
                        maxNumHands: 1, 
                        modelComplexity: 1, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });

                    hands.onResults((results) => {
                        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                            const landmarks = results.multiHandLandmarks[0];
                            const wrist = landmarks[0]; 
                            const thumbTip = landmarks[4]; const middleTip = landmarks[12];
                            
                            // 1. å¼ å¼€/æ¡æ‹³æ£€æµ‹
                            const tips = [8, 12, 16, 20]; const bases = [5, 9, 13, 17];
                            let tD = 0; let bD = 0;
                            for(let i=0; i<4; i++){
                                tD += Math.sqrt(Math.pow(landmarks[tips[i]].x - wrist.x, 2) + Math.pow(landmarks[tips[i]].y - wrist.y, 2));
                                bD += Math.sqrt(Math.pow(landmarks[bases[i]].x - wrist.x, 2) + Math.pow(landmarks[bases[i]].y - wrist.y, 2));
                            }
                            const ratio = tD / bD; 
                            
                            // 2. è‡ªé€‚åº”æåˆåˆ¤å®š
                            const handSize = Math.sqrt(Math.pow(landmarks[5].x - wrist.x, 2) + Math.pow(landmarks[5].y - wrist.y, 2));
                            const snapDist = Math.sqrt(Math.pow(thumbTip.x - middleTip.x, 2) + Math.pow(thumbTip.y - middleTip.y, 2));
                            
                            const isPinching = snapDist < (handSize * 0.25); 
                            
                            if (isPinching && !isExploding) {
                                pinchTimer++;
                                statusText.innerHTML = "âš¡ è“„åŠ›ä¸­... âš¡";
                                statusText.classList.add("charging");
                                targetScale *= 1.1; 
                                if (pinchTimer > 10) { 
                                    triggerExplosion();
                                    pinchTimer = 0;
                                }
                            } else {
                                pinchTimer = 0;
                                statusText.classList.remove("charging");

                                if (ratio < 1.3) {
                                    targetScale = 0.5;
                                    if (!isExploding) statusText.innerHTML = "âœŠ æ¡æ‹³ç¼©å°";
                                } else {
                                    let s = (ratio - 1.1) / 0.6; 
                                    targetScale = 0.5 + (Math.max(0, Math.min(1, s)) * 1.8); 
                                    if (!isExploding) statusText.innerHTML = "âœ¨ æ˜Ÿæ²³å·²è¿æ¥ | æåˆæ‰‹æŒ‡è§¦å‘é­”æ³• âœ¨";
                                }
                            }

                            if (mode !== 'hand') { mode = 'hand'; }
                            const middleBase = landmarks[9]; 
                            targetRotY = (middleBase.x - 0.5) * 4.0;
                            let tilt = (middleBase.z - wrist.z) * 12; 
                            targetRotX = Math.max(-0.5, Math.min(0.5, tilt));
                        } else { 
                            if (mode === 'hand') { targetScale = 1.0; targetRotX = 0; targetRotY = 0; pinchTimer = 0; } 
                        }
                    });
                    
                    const cameraUtils = new Camera(videoElement, { 
                        onFrame: async () => { await hands.send({image: videoElement}); }, 
                        width: 640, 
                        height: 480 
                    });
                    
                    cameraUtils.start().catch((error) => {
                        console.error("Camera Start Error:", error);
                        statusText.innerHTML = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚ç‚¹å‡»å±å¹•ä½œä¸ºåå¤‡ã€‚";
                        statusText.style.color = "#ff5555";
                        statusText.classList.remove("highlight");
                        mode = 'mouse';
                    });
                    
                } catch(e) { 
                    console.error("AI Initialization Error:", e); 
                    statusText.innerHTML = "âŒ AI åˆå§‹åŒ–å¤±è´¥ï¼Œå·²åˆ‡æ¢ä¸ºé¼ æ ‡ç‚¹å‡»æ¨¡å¼ã€‚";
                    statusText.style.color = "#ff5555";
                    mode = 'mouse';
                }
            }
        }
    </script>
</body>
</html>